
#include <iostream>
#include <chrono>

#include <unistd.h>
#include <cstdarg>

#include "../../Tiny2D.h"

// Very simple button rendering class example. 
class Button
{
public:
	Button(int pX,int pY,int pWidth,int pHeight,const char* pText)
	{
		mRect.FromX = pX;
		mRect.FromY = pY;
		mRect.ToX = pX + pWidth;
		mRect.ToY = pY + pHeight;
		SetText(pText);
		SetColour(150,150,150);
		SetTextColour(0,0,0);
		SetTextPressedColour(200,200,200);
	}

	void Render(tiny2d::DrawBuffer& pRT,const tiny2d::PixelFont& pFont,int pMouseX,int pMouseY,bool pClick)
	{
		const bool isIn = mRect.GetPointIsIn(pMouseX,pMouseY);
		const bool pressed = isIn && pClick;

		pRT.FillRectangle(mRect.FromX,mRect.FromY,mRect.ToX,mRect.ToY,mFillColour.r,mFillColour.g,mFillColour.b);
	
		if( pressed )
		{
			pRT.DrawLineH(mRect.FromX,mRect.FromY,mRect.ToX,mDarkColour.r,mDarkColour.g,mDarkColour.b);
			pRT.DrawLineV(mRect.FromX,mRect.FromY,mRect.ToY,mDarkColour.r,mDarkColour.g,mDarkColour.b);
	
			pRT.DrawLineH(mRect.FromX,mRect.ToY,mRect.ToX,mLightColour.r,mLightColour.g,mLightColour.b);
			pRT.DrawLineV(mRect.ToX,mRect.FromY,mRect.ToY,mLightColour.r,mLightColour.g,mLightColour.b);
		}
		else
		{
			pRT.DrawLineH(mRect.FromX,mRect.FromY,mRect.ToX,mLightColour.r,mLightColour.g,mLightColour.b);
			pRT.DrawLineV(mRect.FromX,mRect.FromY,mRect.ToY,mLightColour.r,mLightColour.g,mLightColour.b);
	
			pRT.DrawLineH(mRect.FromX,mRect.ToY,mRect.ToX,mDarkColour.r,mDarkColour.g,mDarkColour.b);
			pRT.DrawLineV(mRect.ToX,mRect.FromY,mRect.ToY,mDarkColour.r,mDarkColour.g,mDarkColour.b);
		}
	
		if(mText.size()>0)
		{
			// Need to add font hot spot thing to font, IE center at x,y rendering. But for now do here in the button code.
			int x = (mRect.FromX + mRect.ToX) / 2;
			int y = (mRect.FromY + mRect.ToY) / 2;
			
			int len = mText.size();
			x -= (len*8)/2;
			y -= 13/2;
	
			if( isIn )
				pFont.Print(pRT,x,y,mTextPressedColour.r,mTextPressedColour.g,mTextPressedColour.b,mText);
			else
				pFont.Print(pRT,x,y,mTextColour.r,mTextColour.g,mTextColour.b,mText);
		}
	}
	
	void SetText(const std::string& pText)
	{
		mText = pText;
	}
	
	void SetTextf(const char* pFmt,...)
	{
		char buf[1024];	
		va_list args;
		va_start(args, pFmt);
		vsnprintf(buf, sizeof(buf), pFmt, args);
		va_end(args);
		SetText(buf);
	}

	void SetColour(uint8_t pRed,uint8_t pGreen,uint8_t pBlue)	// Makes mLightColour a bright version of the colour, mDarkColour a darkened version and sets the mFillColour to the colour passed in. Does not change text colour.	
	{
		SetLightColour((uint8_t)std::min(255,((int)pRed<<1)),(uint8_t)std::min(255,((int)pGreen<<1)),(uint8_t)std::min(255,((int)pBlue<<1)));
		SetFillColour(pRed,pGreen,pBlue);
		SetDarkColour(pRed>>1,pGreen>>1,pBlue>>1);
	}

	void SetLightColour(uint8_t pRed,uint8_t pGreen,uint8_t pBlue)
	{
		mLightColour.r = pRed;
		mLightColour.g = pGreen;
		mLightColour.b = pBlue;
	}
	
	void SetFillColour(uint8_t pRed,uint8_t pGreen,uint8_t pBlue)
	{
		mFillColour.r = pRed;
		mFillColour.g = pGreen;
		mFillColour.b = pBlue;
	}
	
	void SetDarkColour(uint8_t pRed,uint8_t pGreen,uint8_t pBlue)
	{
		mDarkColour.r = pRed;
		mDarkColour.g = pGreen;
		mDarkColour.b = pBlue;
	}
	
	void SetTextColour(uint8_t pRed,uint8_t pGreen,uint8_t pBlue)
	{
		mTextColour.r = pRed;
		mTextColour.g = pGreen;
		mTextColour.b = pBlue;
	}
	
	void SetTextPressedColour(uint8_t pRed,uint8_t pGreen,uint8_t pBlue)
	{
		mTextPressedColour.r = pRed;
		mTextPressedColour.g = pGreen;
		mTextPressedColour.b = pBlue;
	}

	bool GetPointIsIn(int pX,int pY)
	{
		return mRect.GetPointIsIn(pX,pY);
	}

		
private:
	
	struct
	{
		int FromX,FromY,ToX,ToY;

		bool GetPointIsIn(int pX,int pY)
		{
			return FromX < pX && ToX > pX && FromY < pY && ToY > pY;
		}
	}mRect;

	struct
	{
		uint8_t r,g,b;
	}mLightColour,mFillColour,mDarkColour,mTextColour,mTextPressedColour;

	std::string mText;
};


int main(int argc, char *argv[])
{
// Say hello to the world!
    std::cout << "Hello world, a skeleton app generated by appbuild.\n";

// Display the constants defined by app build. \n";
    std::cout << "Application Version " << APP_VERSION << '\n';
    std::cout << "Build date and time " << APP_BUILD_DATE_TIME << '\n';
    std::cout << "Build date " << APP_BUILD_DATE << '\n';
    std::cout << "Build time " << APP_BUILD_TIME << '\n';

	tiny2d::FrameBuffer* FB = tiny2d::FrameBuffer::Open(tiny2d::FrameBuffer::VERBOSE_MESSAGES);
	if( !FB )
		return 1;

    tiny2d::DrawBuffer RT(FB);
	RT.Clear(150,150,150);

	srand(time(NULL));


	tiny2d::PixelFont TheFont(3);
	Button TheButton(100,100,150,50,"This is a button");
	Button GreenButton(200,200,150,50,"A green button");
	Button QuitButton(300,300,150,50,"Quit!");
	GreenButton.SetColour(30,150,30);

	TheFont.SetPenColour(0,0,0);

	int MouseX = 0,MouseY = 0;
	bool MouseClick = false;
	bool ButtonPressed = false;
	FB->SetSystemEventHandler([&MouseX,&MouseY,&MouseClick,&ButtonPressed](const tiny2d::SystemEventData& pData)
	{
		switch(pData.mType)
		{
		case tiny2d::SYSTEM_EVENT_EXIT_REQUEST:
			break;

		case tiny2d::SYSTEM_EVENT_POINTER_MOVE:
			MouseX = pData.mPointer.X;
			MouseY = pData.mPointer.Y;
			break;

		case tiny2d::SYSTEM_EVENT_POINTER_UP:
			MouseX = pData.mPointer.X;
			MouseY = pData.mPointer.Y;
			MouseClick = false;
			ButtonPressed = true;
			break;

		case tiny2d::SYSTEM_EVENT_POINTER_DOWN:
			MouseX = pData.mPointer.X;
			MouseY = pData.mPointer.Y;
			MouseClick = true;
			break;
		}
	});

	int FPS = 0;
	int n = 149;
	while(FB->GetKeepGoing())
	{
		auto frameStart = std::chrono::system_clock::now();

		RT.Clear(150,150,150);
		TheFont.SetPixelSize(5);
		TheFont.Printf(RT,0,0,"Counting %d",n);


		TheFont.SetPixelSize(1);
		TheFont.Printf(RT,RT.GetWidth() - 60,0,"FPS %d",FPS);

		TheFont.SetPixelSize(1);
		TheButton.Render(RT,TheFont,MouseX,MouseY,MouseClick);
		GreenButton.Render(RT,TheFont,MouseX,MouseY,MouseClick);
		QuitButton.Render(RT,TheFont,MouseX,MouseY,MouseClick);

		RT.FillCircle(MouseX,MouseY,20,255,255,255);

		if( ButtonPressed )// Most basic GUI
		{
			ButtonPressed = false;
			if( TheButton.GetPointIsIn(MouseX,MouseY) )
			{
				n += rand()&0xff;
			}

			if( GreenButton.GetPointIsIn(MouseX,MouseY) )
			{
				n -= rand()&0xff;
			}

			if( QuitButton.GetPointIsIn(MouseX,MouseY) )
			{
				FB->OnApplicationExitRequest();
			}
		}
		
		FB->Present(RT);

		auto frameEnd = std::chrono::system_clock::now();
		std::chrono::duration<float,std::milli> time = (frameEnd - frameStart);
		FPS = (int)(1000.0f / time.count());

	};

	delete FB;

// And quit;
    return EXIT_SUCCESS;
}
